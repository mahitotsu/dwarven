# Architecture Decision Records (ADR)

## ADR-001: src layout の採用

**日付**: 2026-02-12  
**ステータス**: 採用

### コンテキスト
Pythonプロジェクトのディレクトリ構造として、フラット構造と src layout の2つの選択肢がある。

### 決定
src layout を採用する。

### 理由
1. **名前空間の衝突回避**: ローカルモジュールとインストールされたモジュールの混同を防ぐ
2. **テストの信頼性**: インストールされたパッケージに対してテストを実行できる
3. **モダンなベストプラクティス**: Python Packaging Authorityが推奨
4. **エディターサポート**: IDEとの親和性が高い

### 影響
- `src/csv_analyzer/` 以下にすべてのソースコードを配置
- インポートは `from csv_analyzer import ...` の形式
- pyproject.toml で適切にパッケージを定義

---

## ADR-002: uv によるパッケージ管理

**日付**: 2026-02-12  
**ステータス**: 採用

### コンテキスト
Python の依存関係管理ツールとして、pip、poetry、uv などの選択肢がある。

### 決定
uv を依存関係管理ツールとして採用する。

### 理由
1. **高速**: pip よりも大幅に高速（10-100倍）
2. **シンプル**: requirements.txt や setup.py 不要
3. **pyproject.toml ネイティブ**: モダンな標準に準拠
4. **ロックファイル**: 再現可能なビルド
5. **Python バージョン管理**: Python 自体のインストールも可能

### 影響
- `pyproject.toml` に依存関係を定義
- `uv.lock` で依存関係を固定
- インストールは `uv pip install -e ".[dev]"`
- requirements.txt は作成しない

---

## ADR-003: matplotlib によるグラフ生成

**日付**: 2026-02-12  
**ステータス**: 採用

### コンテキスト
グラフ生成ライブラリとして matplotlib と plotly の2つの選択肢がある。

### 決定
matplotlib を採用する。

### 理由
1. **安定性**: 長年使用されている実績
2. **静的グラフ**: HTMLに埋め込みやすい（Base64エンコード）
3. **軽量**: plotly よりも依存関係が少ない
4. **ドキュメント**: 豊富なリソース
5. **シンプルさ**: 要件に対して十分な機能

### 代替案
- **plotly**: インタラクティブなグラフが必要な場合に有効だが、今回の要件では不要

### 影響
- matplotlib と必要な依存関係を pyproject.toml に追加
- グラフは PNG として生成し、Base64 エンコードして HTML に埋め込む

---

## ADR-004: Jinja2 による HTML テンプレート

**日付**: 2026-02-12  
**ステータス**: 採用

### コンテキスト
HTMLレポートの生成方法として、文字列結合、テンプレートエンジン、HTMLライブラリなどの選択肢がある。

### 決定
Jinja2 テンプレートエンジンを使用する。

### 理由
1. **保守性**: テンプレートとロジックの分離
2. **可読性**: HTMLの構造が明確
3. **再利用性**: テンプレートの拡張・継承が容易
4. **標準的**: Flask など多くのフレームワークで使用
5. **セキュリティ**: 自動エスケープ機能

### 代替案
- **文字列結合**: シンプルだが保守性が低い
- **dominate**: Pythonic だが学習コストが高い

### 影響
- jinja2 を依存関係に追加
- `src/csv_analyzer/templates/report.html` にテンプレートを配置
- テンプレートエンジンの初期化コードが必要

---

## ADR-005: dataclasses によるデータモデル

**日付**: 2026-02-12  
**ステータス**: 採用

### コンテキスト
データ構造の定義方法として、dict、namedtuple、dataclass、Pydantic などの選択肢がある。

### 決定
Python 標準ライブラリの dataclasses を使用する。

### 理由
1. **標準ライブラリ**: 追加依存なし
2. **型ヒント**: mypy による型チェックが可能
3. **自動生成**: `__init__`, `__repr__` などが自動生成
4. **不変性**: `frozen=True` で immutable にできる
5. **シンプル**: 学習コストが低い

### 代替案
- **Pydantic**: バリデーション機能が豊富だが、今回は過剰
- **dict**: 型安全性がない

### 影響
- モデル定義に `@dataclass` デコレーターを使用
- 型ヒントを必須とする
- バリデーションは `__post_init__` で実装

---

## ADR-006: ruff による Linting と Formatting

**日付**: 2026-02-12  
**ステータス**: 採用

### コンテキスト
コード品質管理ツールとして、black + flake8 + isort の組み合わせと、ruff の選択肢がある。

### 決定
ruff を採用する。

### 理由
1. **オールインワン**: Linting と Formatting を統合
2. **高速**: Rust 実装で非常に高速
3. **互換性**: black、flake8、isort のルールをカバー
4. **シンプル**: 設定ファイルが少ない
5. **モダン**: 最新のベストプラクティスに準拠

### 影響
- black、flake8、isort は使用しない
- ruff のみを dev dependencies に追加
- pyproject.toml に ruff の設定を記載

---

## ADR-007: pytest によるテスト

**日付**: 2026-02-12  
**ステータス**: 採用

### コンテキスト
テストフレームワークとして unittest（標準ライブラリ）と pytest の選択肢がある。

### 決定
pytest を採用する。

### 理由
1. **シンプルな構文**: assert 文だけで十分
2. **豊富な機能**: fixture、parametrize など
3. **プラグインエコシステム**: カバレッジ、モックなど
4. **発見機能**: テストファイルの自動検出
5. **エラーメッセージ**: 詳細で分かりやすい

### 影響
- pytest を dev dependencies に追加
- テストファイルは `test_*.py` の命名規則
- fixtures を活用してテストデータを準備

---

## ADR-008: mypy による型チェック

**日付**: 2026-02-12  
**ステータス**: 採用

### コンテキスト
静的型チェックツールとして mypy、pyright などの選択肢がある。

### 決定
mypy を採用する。

### 理由
1. **デファクトスタンダード**: 最も広く使用されている
2. **柔軟な設定**: 段階的な型チェックが可能
3. **コミュニティ**: 豊富なリソース
4. **統合**: 多くのエディターでサポート

### 影響
- mypy を dev dependencies に追加
- strict モードを有効化
- すべての関数に型ヒントを記述

---

## ADR-009: argparse によるCLI実装

**日付**: 2026-02-12  
**ステータス**: 採用

### コンテキスト
CLI実装として argparse（標準ライブラリ）、click、typer などの選択肢がある。

### 決定
argparse を採用する。

### 理由
1. **標準ライブラリ**: 追加依存なし
2. **十分な機能**: 今回の要件に対して過不足ない
3. **学習コスト**: 広く知られている
4. **軽量**: オーバーヘッドが少ない

### 代替案
- **click/typer**: より高度なCLIには有効だが、今回は不要

### 影響
- 追加の依存関係なし
- main.py で argparse を使用してコマンドライン引数を処理
